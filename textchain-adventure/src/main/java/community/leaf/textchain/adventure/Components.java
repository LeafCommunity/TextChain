/*
 * Copyright Â© 2021-2024, RezzedUp <https://github.com/LeafCommunity/TextChain>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package community.leaf.textchain.adventure;

import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.ComponentLike;
import net.kyori.adventure.text.TextComponent;
import net.kyori.adventure.text.format.NamedTextColor;
import net.kyori.adventure.text.format.Style;
import net.kyori.adventure.text.format.TextDecoration;
import pl.tlinkowski.annotation.basic.NullOr;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Utilities and constants for working with Adventure components.
 */
public class Components
{
    private Components() { throw new UnsupportedOperationException(); }
    
    /**
     * Style constant that explicitly <b>disables</b> most formatting options
     * (all {@link TextDecoration decoration types} are set to false). No color is specified, however,
     * so the color from a parent style will still be inherited when it's applied to a child component.
     */
    public static final Style UNFORMATTED =
        Style.style()
            .decoration(TextDecoration.BOLD, false)
            .decoration(TextDecoration.ITALIC, false)
            .decoration(TextDecoration.OBFUSCATED, false)
            .decoration(TextDecoration.STRIKETHROUGH, false)
            .decoration(TextDecoration.UNDERLINED, false)
            .build();
    
    /**
     * Style constant that explicitly <b>disables</b> most formatting options
     * (all {@link TextDecoration decoration types} are set to false), and it's set to <b>white</b>
     * (emulating the {@code "&r"} legacy color code).
     */
    public static final Style RESET = UNFORMATTED.color(NamedTextColor.WHITE);
    
    /**
     * Safely retrieves the component from the provided component-like by throwing NPEs if {@code null}
     * is encountered anywhere in the component conversion process.
     *
     * @param componentLike     a suspicious component-like (received via input)
     *
     * @return the component version of the provided component-like
     * @throws NullPointerException if componentLike or the component it returns is null
     */
    public static Component safelyAsComponent(ComponentLike componentLike)
    {
        Objects.requireNonNull(componentLike, "componentLike");
        return Objects.requireNonNull(componentLike.asComponent(), "componentLike returned null");
    }
    
    /**
     * Safely converts the provided component-like into a text component builder. If the component-like
     * returns a {@link TextComponent}, it is converted directly into the resulting builder. Any other
     * component type is simply appended to a new text component builder.
     *
     * @param componentLike     a suspicious component-like (received via input)
     *
     * @return a text component builder composed of the provided component-like
     */
    public static TextComponent.Builder safelyAsTextComponentBuilder(ComponentLike componentLike)
    {
        Component component = Components.safelyAsComponent(componentLike);
        return (component instanceof TextComponent)
            ? ((TextComponent) component).toBuilder()
            : Component.text().append(component);
    }
    
    /**
     * Flattens a component's {@code extra} components (its {@link Component#children() children})
     * by applying the provided component's {@link Component#style() style} to each child component.
     *
     * @param component     the component with "extra" to flatten
     *
     * @return a list of the component's flattened children
     */
    public static List<Component> flattenExtra(Component component)
    {
        Objects.requireNonNull(component, "component");
        List<Component> flattened = new ArrayList<>();
        for (Component extra : component.children()) { flattened.add(extra.style(component.style())); }
        return flattened;
    }
    
    /**
     * Combines and flattens a component's {@code extra} components (its {@link Component#children() children})
     * by first aggregating them until a new line is encountered and then applying the provided component's
     * {@link Component#style() style} to each combined group of children. A child component is eligible
     * to be combined unless it <b>equals</b> {@link Component#newline()} (a text component containing only
     * {@code "\n"}), in which case a new group of children is started.
     *
     * @param component     the component with "extra" to flatten
     *
     * @return a list of components generated by combining and flattening the component's children
     */
    public static List<Component> flattenExtraSplitByNewLine(Component component)
    {
        Objects.requireNonNull(component, "component");
        
        List<Component> flattened = new ArrayList<>();
        TextComponent.@NullOr Builder builder = null;
        
        for (Component extra : component.children())
        {
            if (Component.newline().equals(extra))
            {
                if (builder != null)
                {
                    flattened.add(builder.build());
                    builder = null;
                }
                
                continue;
            }
            
            if (builder == null) { builder = Component.text().style(component.style()); }
            builder.append(extra);
        }
        
        if (builder != null) { flattened.add(builder.build()); }
        return flattened;
    }
}
